// Licensed under the Apache License, Version 2.0.
// See LICENSE file in the project root for full license information.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Incursa.Generators;

public static class StringBackedEnumTypeGenerator
{
    private const int MatchMethodThreshold = 25;

    public static GeneratorParams? GetParams(XElement xml, IBgLogger? logger, string sourceFilePath)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        var enumValues = xml.Elements("Value").Select(e => e.GetAttributeDict()).Select(a => (a["value"].ToString(), a["name"].ToString(), a.TryGetValue("display") ?? a["name"].ToString(), a.TryGetValue("documentation"))).ToList();
        var additionalProperties = xml.Elements("Property").Select(e => e.GetAttributeDict()).Select(a => (a["type"].ToString(), a["name"].ToString())).ToList();
        return new(attributes.TryGetValue("name"), attributes.TryGetValue("namespace"), true, enumValues, additionalProperties, sourceFilePath);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate is { } sg)
        {
            return GenerateMainFile(sg);
        }

        return null;
    }

    public static string? GenerateDataFile(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate is { } sg)
        {
            return GenerateData(sg);
        }

        return null;
    }

    public static string? GenerateConvertersFile(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate is { } sg)
        {
            return GenerateConverters(sg);
        }

        return null;
    }

    public static string? GenerateValueConverter(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return ValueConverterGenerator.GenerateStringBackedEnumConverter(
                structToGenerate.Value.Name,
                structToGenerate.Value.Namespace);
        }
        else
        {
            return null;
        }
    }

    private static string GenerateMainFile(GeneratorParams relatedClass)
    {
        var enumCount = relatedClass.EnumValues?.Count ?? 0;
        if (enumCount == 0)
        {
            return string.Empty;
        }

        var licenseHeader = relatedClass.LicenseHeader ?? string.Empty;
        var sb = new System.Text.StringBuilder();

        // Additional properties handling
        var additionalPropertiesDeclaration = string.Empty;
        var additionalPropertiesInit = string.Empty;
        var processValueSignature = "static partial void ProcessValue(int index);";
        
        if (relatedClass.AdditionalProperties is { Count: > 0 })
        {
            foreach (var p in relatedClass.AdditionalProperties)
            {
                sb.Append("    public ").Append(p.Type).Append(' ').Append(p.Name).AppendLine(" { get; init; }");
            }
            additionalPropertiesDeclaration = sb.ToString();
            sb.Clear();

            for (int i = 0; i < relatedClass.AdditionalProperties.Count; i++)
            {
                if (i > 0) sb.Append(", ");
                var p = relatedClass.AdditionalProperties[i];
                sb.Append("out ").Append(p.Type).Append(' ').Append(p.Name.ToLowerInvariant());
            }
            var outParams = sb.ToString();
            sb.Clear();

            processValueSignature = $"private static partial void ProcessValue(int index, {outParams});";

            sb.Append("        ProcessValue(this.index, ");
            for (int i = 0; i < relatedClass.AdditionalProperties.Count; i++)
            {
                if (i > 0) sb.Append(", ");
                var p = relatedClass.AdditionalProperties[i];
                sb.Append("out var ").Append(p.Name.ToLowerInvariant());
            }
            sb.AppendLine(");");
            foreach (var p in relatedClass.AdditionalProperties)
            {
                sb.Append("        ").Append(p.Name).Append(" = ").Append(p.Name.ToLowerInvariant()).AppendLine(";");
            }
            additionalPropertiesInit = sb.ToString();
            sb.Clear();
        }

        // Generate Match methods only if count is below threshold
        var matchMethods = string.Empty;
        if (enumCount <= MatchMethodThreshold)
        {
            matchMethods = GenerateMatchMethods(relatedClass);
        }

        var licenseHeaderSection = string.IsNullOrEmpty(licenseHeader) ? string.Empty : $"{licenseHeader}\n\n";

        return $$"""
// <auto-generated/>
{{licenseHeaderSection}}#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;
using CommunityToolkit.Diagnostics;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
[System.CodeDom.Compiler.GeneratedCode("StringBackedEnumGenerator","1.0.0")]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>
{
    private readonly int index;

{{additionalPropertiesDeclaration}}
    private {{relatedClass.Name}}(int index)
    {
        this.index = index;
{{additionalPropertiesInit}}
    }

    public string Value => {{relatedClass.Name}}.values[this.index];

    public string DisplayName => {{relatedClass.Name}}.displayNames[this.index];

    public int Index => this.index;

    public static {{relatedClass.Name}} From(string value) => Parse(value);

    {{processValueSignature}}

    public override string ToString() => Value;

    public bool Equals({{relatedClass.Name}} other) => this.index == other.index;

    public override int GetHashCode() => this.index;

    public int CompareTo({{relatedClass.Name}} other) => string.Compare(Value, other.Value, StringComparison.Ordinal);

    public int CompareTo(object? obj)
    {
        if (obj is {{relatedClass.Name}} other)
            return CompareTo(other);
        return Value.CompareTo(obj);
    }

    public static bool operator <({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) < 0;

    public static bool operator <=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) <= 0;

    public static bool operator >({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) > 0;

    public static bool operator >=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) >= 0;

{{matchMethods}}

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;

        return {{relatedClass.Name}}.indexByValue.TryGetValue(value, out var index) ? new {{relatedClass.Name}}(index) : null;
    }

    public static bool TryParse(string? value, out {{relatedClass.Name}} parsed) => TryParse(value, null, out parsed);

    public static {{relatedClass.Name}} Parse(string value) => Parse(value, null);

    public static {{relatedClass.Name}} Parse(string s, IFormatProvider? provider)
    {
        Guard.IsNotNull(s);

        if (TryParse(s, provider, out {{relatedClass.Name}} parsed))
        {
            return parsed;
        }
        else
        {
            throw new ArgumentOutOfRangeException(nameof(s), $"The value '{s}' is not a valid {{relatedClass.Name}}.");
        }
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{relatedClass.Name}} result)
    {
        {{relatedClass.Name}}? parsed = TryParse(s);
        if (parsed.HasValue)
        {
            result = parsed.Value;
            return true;
        }

        result = default;
        return false;
    }
}

""";
    }

    private static string GenerateData(GeneratorParams relatedClass)
    {
        var enumCount = relatedClass.EnumValues?.Count ?? 0;
        if (enumCount == 0)
        {
            return string.Empty;
        }

        var licenseHeader = relatedClass.LicenseHeader ?? string.Empty;
        var licenseHeaderSection = string.IsNullOrEmpty(licenseHeader) ? string.Empty : $"{licenseHeader}\n\n";
        var sb = new System.Text.StringBuilder();

        // Generate value constants
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("    public const string ").Append(p.Name).Append("Value = \"").Append(p.Value).AppendLine("\";");
        }
        var constValues = sb.ToString();
        sb.Clear();

        // Generate display name constants
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("    public const string ").Append(p.Name).Append("DisplayName = \"").Append(p.DisplayName).AppendLine("\";");
        }
        var constDisplayNames = sb.ToString();
        sb.Clear();

        // Generate named instances
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            if (p.Documentation != null)
            {
                sb.Append("    /// <summary>\r\n    /// ").Append(p.Documentation).AppendLine("\r\n    /// </summary>");
            }
            sb.Append("    public static readonly ").Append(relatedClass.Name).Append(' ').Append(p.Name)
              .Append(" = new(").Append(i).AppendLine(");");
        }
        var namedInstances = sb.ToString();
        sb.Clear();

        // Generate values array
        sb.AppendLine("new string[]");
        sb.AppendLine("        {");
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            \"").Append(p.Value).AppendLine("\",");
        }
        sb.Append("        }");
        var valuesArray = sb.ToString();
        sb.Clear();

        // Generate display names array
        sb.AppendLine("new string[]");
        sb.AppendLine("        {");
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            \"").Append(p.DisplayName).AppendLine("\",");
        }
        sb.Append("        }");
        var displayNamesArray = sb.ToString();
        sb.Clear();

        return $$"""
// <auto-generated/>
{{licenseHeaderSection}}#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.Collections.Generic;

public readonly partial record struct {{relatedClass.Name}}
{
{{constValues}}
{{constDisplayNames}}
{{namedInstances}}

    private static readonly string[] values = {{valuesArray}};

    private static readonly string[] displayNames = {{displayNamesArray}};

    private static readonly Dictionary<string, int> indexByValue = CreateIndex();

    public static IReadOnlyList<{{relatedClass.Name}}> AllValues { get; } = CreateAllValues();

    private static Dictionary<string, int> CreateIndex()
    {
        var dict = new Dictionary<string, int>({{relatedClass.Name}}.values.Length, StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < {{relatedClass.Name}}.values.Length; i++)
        {
            dict[{{relatedClass.Name}}.values[i]] = i;
        }
        return dict;
    }

    private static {{relatedClass.Name}}[] CreateAllValues()
    {
        var arr = new {{relatedClass.Name}}[{{relatedClass.Name}}.values.Length];
        for (int i = 0; i < arr.Length; i++)
        {
            arr[i] = new {{relatedClass.Name}}(i);
        }
        return arr;
    }
}

""";
    }

    private static string GenerateConverters(GeneratorParams relatedClass)
    {
        var licenseHeader = relatedClass.LicenseHeader ?? string.Empty;
        var licenseHeaderSection = string.IsNullOrEmpty(licenseHeader) ? string.Empty : $"{licenseHeader}\n\n";

        return $$"""
// <auto-generated/>
{{licenseHeaderSection}}#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

public readonly partial record struct {{relatedClass.Name}}
{
    [System.CodeDom.Compiler.GeneratedCode("StringBackedEnumGenerator","1.0.0")]
    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.Name}}.TryParse(s, out {{relatedClass.Name}} result))
            {
                return result;
            }

            throw new JsonException($"Invalid value for {{relatedClass.Name}}: {s}");
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value);

        public override void WriteAsPropertyName(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WritePropertyName(value.Value);

        public override {{relatedClass.Name}} ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            return this.Read(ref reader, typeToConvert, options);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("StringBackedEnumGenerator","1.0.0")]
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return {{relatedClass.Name}}.TryParse(s) ?? default;
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type && destinationType == typeof(string))
            {
                return type.ToString();
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    private static string GenerateMatchMethods(GeneratorParams relatedClass)
    {
        var enumCount = relatedClass.EnumValues?.Count ?? 0;
        var sb = new System.Text.StringBuilder();

        // Generate match params
        for (int i = 0; i < enumCount; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append("Action case").Append(relatedClass.EnumValues![i].Name);
        }
        var matchParams = sb.ToString();
        sb.Clear();

        // Generate matchT params
        for (int i = 0; i < enumCount; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append($"Func<{relatedClass.Name}> case").Append(relatedClass.EnumValues![i].Name);
        }
        var matchTParams = sb.ToString();
        sb.Clear();

        // Generate match cases using index
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            case ").Append(i).AppendLine(":");
            sb.Append("                case").Append(p.Name).AppendLine("();");
            sb.AppendLine("                return;");
        }
        var matchCases = sb.ToString();
        sb.Clear();

        // Generate matchT cases using index
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            case ").Append(i).AppendLine(":");
            sb.Append("                return case").Append(p.Name).AppendLine("();");
        }
        var matchTCases = sb.ToString();
        sb.Clear();

        // Generate tryMatch cases using index
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            case ").Append(i).AppendLine(":");
            sb.Append("                case").Append(p.Name).AppendLine("();");
            sb.AppendLine("                return true;");
        }
        var tryMatchCases = sb.ToString();
        sb.Clear();

        // Generate tryMatchT cases using index
        for (int i = 0; i < enumCount; i++)
        {
            var p = relatedClass.EnumValues![i];
            sb.Append("            case ").Append(i).AppendLine(":");
            sb.Append("                result = case").Append(p.Name).AppendLine("();");
            sb.AppendLine("                return true;");
        }
        var tryMatchTCases = sb.ToString();
        sb.Clear();

        return $$"""
    /// <summary>
    /// Matches the current enum value against all possible cases and executes the corresponding delegate.
    /// Throws <see cref="ArgumentOutOfRangeException"/> if no match is found.
    /// </summary>
{{string.Join("\r\n", relatedClass.EnumValues.Select(p => $"    /// <param name=\"case{p.Name}\">The delegate to execute for the {p.Name} case.</param>"))}}
    /// <exception cref="ArgumentOutOfRangeException">Thrown when the current value is not handled by any case.</exception>
    public void Match({{matchParams}})
    {
        switch (this.index)
        {
{{matchCases}}
            default:
                throw new ArgumentOutOfRangeException(nameof(this.index), "Internal index is not valid.");
        }
    }

    /// <summary>
    /// Matches the current enum value against all possible cases and returns the result of executing the corresponding delegate.
    /// Throws <see cref="ArgumentOutOfRangeException"/> if no match is found.
    /// </summary>
{{string.Join("\r\n", relatedClass.EnumValues.Select(p => $"    /// <param name=\"case{p.Name}\">The delegate to execute for the {p.Name} case.</param>"))}}
    /// <returns>The result of executing the matching delegate.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when the current value is not handled by any case.</exception>
    public {{relatedClass.Name}} Match({{matchTParams}})
    {
        switch (this.index)
        {
{{matchTCases}}
            default:
                throw new ArgumentOutOfRangeException(nameof(this.index), "Internal index is not valid.");
        }
    }

    /// <summary>
    /// Attempts to match the current enum value against all possible cases and executes the corresponding delegate.
    /// Returns false if no match is found.
    /// </summary>
{{string.Join("\r\n", relatedClass.EnumValues.Select(p => $"    /// <param name=\"case{p.Name}\">The delegate to execute for the {p.Name} case.</param>"))}}
    /// <returns>True if a match was found and the corresponding delegate was executed, false otherwise.</returns>
    public bool TryMatch({{matchParams}})
    {
        switch (this.index)
        {
{{tryMatchCases}}
            default:
                return false;
        }
    }

    /// <summary>
    /// Attempts to match the current enum value against all possible cases and returns the result of executing the corresponding delegate.
    /// Returns false if no match is found.
    /// </summary>
{{string.Join("\r\n", relatedClass.EnumValues.Select(p => $"    /// <param name=\"case{p.Name}\">The delegate to execute for the {p.Name} case.</param>"))}}
    /// <param name="result">The result of executing the matching delegate, if a match was found.</param>
    /// <returns>True if a match was found and the corresponding delegate was executed, false otherwise.</returns>
    public bool TryMatch({{matchTParams}}, out {{relatedClass.Name}} result)
    {
        switch (this.index)
        {
{{tryMatchTCases}}
            default:
                result = default!;
                return false;
        }
    }

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly bool IsPublic;
        public readonly IReadOnlyList<(string Value, string Name, string? DisplayName, string? Documentation)>? EnumValues;
        public readonly IReadOnlyList<(string Type, string Name)>? AdditionalProperties;
        public readonly string? SourceFilePath;
        public readonly string? LicenseHeader;

        public GeneratorParams(string name, string ns, bool isPublic, IReadOnlyList<(string Value, string Name, string? DisplayName, string? Documentation)>? enumValues, IReadOnlyList<(string Type, string Name)>? additionalProperties, string? sourceFilePath, string? licenseHeader = null)
        {
            Name = name;
            Namespace = ns;
            IsPublic = isPublic;
            FullyQualifiedName = string.Join(".", ns, name);
            EnumValues = enumValues;
            AdditionalProperties = additionalProperties;
            SourceFilePath = sourceFilePath;
            LicenseHeader = licenseHeader;
        }
    }
}
