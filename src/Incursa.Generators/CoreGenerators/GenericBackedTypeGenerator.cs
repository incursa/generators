// Licensed under the Apache License, Version 2.0.
// See LICENSE file in the project root for full license information.


using System.Collections.Generic;
using System.Xml.Linq;

namespace Incursa.Generators;

public static class GenericBackedTypeGenerator
{
    public static GeneratorParams? GetParams(XElement xml, IBgLogger? logger, string sourceFilePath)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        return new(attributes.TryGetValue("name"), attributes.TryGetValue("namespace"), attributes.TryGetValue("type"), true, sourceFilePath);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return GenerateClass(structToGenerate.Value);
        }
        else
        {
            return null;
        }
    }

    private static string GenerateClass(in GeneratorParams relatedClass)
    {
        var licenseHeader = relatedClass.LicenseHeader ?? string.Empty;

        return $$"""
// <auto-generated/>
{{licenseHeader}}

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>
{
    public static readonly {{relatedClass.Name}} Default = new(default);

    public {{relatedClass.Name}}({{relatedClass.InnerTypeName}} value)
    {
        this.Value = value;
    }

    public {{relatedClass.InnerTypeName}} Value { get; init; }

    public static {{relatedClass.Name}} Parse(string s, IFormatProvider? provider)
    {
        var parsed = {{relatedClass.InnerTypeName}}.Parse(s, provider);
        return new {{relatedClass.Name}}(parsed);
    }

    public static {{relatedClass.Name}} Parse(string value) => Parse(value, null);

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out {{relatedClass.Name}} result)
    {
        if ({{relatedClass.InnerTypeName}}.TryParse(s, provider, out {{relatedClass.InnerTypeName}} id))
        {
            result = new {{relatedClass.Name}}(id);
            return true;
        }

        result = default;
        return false;
    }

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (TryParse(value, null, out {{relatedClass.Name}} result))
        {
            return result;
        }

        return null;
    }

    public static bool TryParse(string? value, out {{relatedClass.Name}} id) => TryParse(value, null, out id);

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.Value.CompareTo(other.Value);
    }

    public int CompareTo(object? obj)
    {
        if (obj is {{relatedClass.Name}} id)
        {
            return this.Value.CompareTo(id.Value);
        }

        return this.Value.CompareTo(obj);
    }

    public static bool operator <({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) < 0;

    public static bool operator <=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) <= 0;

    public static bool operator >({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) > 0;

    public static bool operator >=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) >= 0;

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }

    public override string ToString() => this.Value.ToString();

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.InnerTypeName}}.TryParse(s, out {{relatedClass.InnerTypeName}} id))
            {
                return new {{relatedClass.Name}}(id);
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value.ToString());

        public override void WriteAsPropertyName(
            Utf8JsonWriter writer,
            {{relatedClass.Name}} value,
            JsonSerializerOptions options) =>
                writer.WritePropertyName(value.ToString());

        public override {{relatedClass.Name}} ReadAsPropertyName(
            ref Utf8JsonReader reader,
            Type typeToConvert,
            JsonSerializerOptions options) =>
                Read(ref reader, typeToConvert, options);
    }

    // TypeConverter for {{relatedClass.Name}} to and from string and {{relatedClass.InnerTypeName}}
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || sourceType == typeof({{relatedClass.InnerTypeName}}) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || destinationType == typeof({{relatedClass.InnerTypeName}}) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return TryParse(s) ?? default;
            }

            if (value is {{relatedClass.InnerTypeName}} g)
            {
                return new {{relatedClass.Name}}(g);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type)
            {
                if (destinationType == typeof(string))
                {
                    return type.ToString();
                }

                if (destinationType == typeof({{relatedClass.InnerTypeName}}))
                {
                    return type.Value;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly string InnerTypeName;
        public readonly bool IsPublic;
        public readonly string? SourceFilePath;
        public readonly string? LicenseHeader;

        public GeneratorParams(string name, string ns, string innerTypeName, bool isPublic, string? sourceFilePath, string? licenseHeader = null)
        {
            Name = name;
            Namespace = ns;
            IsPublic = isPublic;
            FullyQualifiedName = string.Join(".", ns, name);
            InnerTypeName = innerTypeName;
            SourceFilePath = sourceFilePath;
            LicenseHeader = licenseHeader;
        }
    }
}
