// Licensed under the Apache License, Version 2.0.
// See LICENSE file in the project root for full license information.

namespace Incursa.Generators;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

public static class FastIdBackedTypeGenerator
{
    public static GeneratorParams? GetParams(XElement xml, IBgLogger? logger, string sourceFilePath)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        return new(attributes.TryGetValue("name"), attributes.TryGetValue("namespace"), true, sourceFilePath);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return GenerateClass(structToGenerate.Value);
        }
        else
        {
            return null;
        }
    }

    public static string? GenerateValueConverter(GeneratorParams? structToGenerate, IBgLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return ValueConverterGenerator.GenerateFastIdBackedConverter(
                structToGenerate.Value.Name,
                structToGenerate.Value.Namespace);
        }
        else
        {
            return null;
        }
    }

    private static string GenerateClass(GeneratorParams relatedClass)
    {
        var licenseHeader = relatedClass.LicenseHeader ?? string.Empty;

        return $$"""
// <auto-generated/>
{{licenseHeader}}

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>
{
    public static readonly {{relatedClass.Name}} Empty = new(Incursa.FastId.Empty);

    public {{relatedClass.Name}}(Incursa.FastId value)
    {
        this.FastId = value;
    }

    public {{relatedClass.Name}}(long value)
    {
        this.FastId = new Incursa.FastId(value);
    }

    public Incursa.FastId FastId { get; init; }

    public long Value => this.FastId.Value;

    public static {{relatedClass.Name}} GenerateNew() => new(Incursa.FastId.New());

    public static {{relatedClass.Name}} From(Incursa.FastId value) => new(value);

    public static {{relatedClass.Name}} From(long value) => new(value);

    public static {{relatedClass.Name}}? From(Incursa.FastId? value) => value.HasValue ? new(value.Value) : null;

    public static {{relatedClass.Name}}? From(long? value) => value.HasValue ? new(value.Value) : null;

    public static {{relatedClass.Name}} Parse(string s, IFormatProvider? provider) => Parse(s.AsSpan(), provider);

    public static {{relatedClass.Name}} Parse(string value) => Parse(value.AsSpan());

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out {{relatedClass.Name}} result) =>
        TryParse(s.AsSpan(), provider, out result);

    public static {{relatedClass.Name}}? TryParse(string? value) => TryParse(value.AsSpan());

    public static bool TryParse(string? value, out {{relatedClass.Name}} id) =>
        TryParse(value.AsSpan(), out id);

    public static {{relatedClass.Name}} Parse(ReadOnlySpan<char> s) => Parse(s, null);

    public static {{relatedClass.Name}} Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
    {
        var id = Incursa.FastId.Parse(s, provider);
        return new {{relatedClass.Name}}(id);
    }

    public static {{relatedClass.Name}}? TryParse(ReadOnlySpan<char> s)
    {
        if (TryParse(s, null, out {{relatedClass.Name}} id))
        {
            return id;
        }

        return null;
    }

    public static bool TryParse(ReadOnlySpan<char> s, [MaybeNullWhen(false)] out {{relatedClass.Name}} result) =>
        TryParse(s, null, out result);

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{relatedClass.Name}} result)
    {
        if (Incursa.FastId.TryParse(s, provider, out Incursa.FastId id))
        {
            result = new {{relatedClass.Name}}(id);
            return true;
        }

        result = default;
        return false;
    }

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.FastId.CompareTo(other.FastId);
    }

    public int CompareTo(object? obj)
    {
        if (obj is {{relatedClass.Name}} id)
        {
            return this.FastId.CompareTo(id.FastId);
        }

        return this.FastId.CompareTo(obj);
    }

    public static bool operator <({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) < 0;

    public static bool operator <=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) <= 0;

    public static bool operator >({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) > 0;

    public static bool operator >=({{relatedClass.Name}} left, {{relatedClass.Name}} right) => left.CompareTo(right) >= 0;

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.FastId.Equals(other.FastId);
    }

    public override int GetHashCode()
    {
        return this.FastId.GetHashCode();
    }

    public override string ToString() => this.FastId.ToString();

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && Incursa.FastId.TryParse(s, out Incursa.FastId id))
            {
                return new {{relatedClass.Name}}(id);
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value.ToString());

        public override void WriteAsPropertyName(
            Utf8JsonWriter writer,
            {{relatedClass.Name}} value,
            JsonSerializerOptions options) =>
                writer.WritePropertyName(value.ToString());

        public override {{relatedClass.Name}} ReadAsPropertyName(
            ref Utf8JsonReader reader,
            Type typeToConvert,
            JsonSerializerOptions options) =>
                Read(ref reader, typeToConvert, options);
    }

    // TypeConverter for {{relatedClass.Name}} to and from string and Incursa.FastId
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || sourceType == typeof(long) || sourceType == typeof(Incursa.FastId) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || destinationType == typeof(long) || destinationType == typeof(Incursa.FastId) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return TryParse(s) ?? default;
            }

            if (value is long l)
            {
                return new {{relatedClass.Name}}(l);
            }

            if (value is Incursa.FastId g)
            {
                return new {{relatedClass.Name}}(g);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type)
            {
                if (destinationType == typeof(string))
                {
                    return type.ToString();
                }

                if (destinationType == typeof(long))
                {
                    return type.Value;
                }

                if (destinationType == typeof(Incursa.FastId))
                {
                    return type.FastId;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly bool IsPublic;
        public readonly string? SourceFilePath;
        public readonly string? LicenseHeader;

        public GeneratorParams(string name, string ns, bool isPublic, string? sourceFilePath, string? licenseHeader = null)
        {
            this.Name = name;
            this.Namespace = ns;
            this.IsPublic = isPublic;
            this.FullyQualifiedName = string.Join(".", ns, name);
            this.SourceFilePath = sourceFilePath;
            this.LicenseHeader = licenseHeader;
        }
    }
}
