// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace Bravellian.Generators;

using System.Collections.Generic;
using System.Xml.Linq;


public static class GenericBackedTypeGenerator
{
    public static GeneratorParams? GetParams(XElement xml, IBvLogger? logger)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        return new(attributes.TryGetValue("name"), attributes.TryGetValue("namespace"), attributes.TryGetValue("type"), true);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBvLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return GenerateClass(structToGenerate.Value);
        }
        else
        {
            return null;
        }
    }

    private static string GenerateClass(in GeneratorParams relatedClass)
    {
        return $$"""
// <auto-generated/>
// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>,
          Bravellian.IHasValueConverter,
          Bravellian.IPwParsable<{{relatedClass.Name}}>,
          Bravellian.IGenericBackedType<{{relatedClass.Name}}>
{
    public static readonly {{relatedClass.Name}} Default = new(default);

    public {{relatedClass.Name}}({{relatedClass.InnerTypeName}} value)
    {
        this.Value = value;
    }

    public {{relatedClass.InnerTypeName}} Value { get; init; }

    public static {{relatedClass.Name}} Parse(string s, IFormatProvider provider)
    {
        var parsed = {{relatedClass.InnerTypeName}}.Parse(s, provider);
        return new {{relatedClass.Name}}(parsed);
    }

    public static {{relatedClass.Name}} Parse(string value) => Parse(value, null);

    public static bool TryParse([NotNullWhen(true)] string s, IFormatProvider provider, out {{relatedClass.Name}} result)
    {
        if ({{relatedClass.InnerTypeName}}.TryParse(s, provider, out {{relatedClass.InnerTypeName}} id))
        {
            result = new {{relatedClass.Name}}(id);
            return true;
        }

        result = default;
        return false;
    }

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (TryParse(value, null, out {{relatedClass.Name}} result))
        {
            return result;
        }

        return null;
    }

    public static bool TryParse(string? value, out {{relatedClass.Name}} id) => TryParse(value, null, out id);

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.Value.CompareTo(other.Value);
    }

    public int CompareTo(object? obj)
    {
        if (obj is {{relatedClass.Name}} id)
        {
            return this.Value.CompareTo(id.Value);
        }

        return this.Value.CompareTo(obj);
    }

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }

    public override string ToString() => this.Value.ToString();

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.InnerTypeName}}.TryParse(s, out {{relatedClass.InnerTypeName}} id))
            {
                return new {{relatedClass.Name}}(id);
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value.ToString());

        public override void WriteAsPropertyName(
            Utf8JsonWriter writer,
            {{relatedClass.Name}} value,
            JsonSerializerOptions options) =>
                writer.WritePropertyName(value.ToString());

        public override {{relatedClass.Name}} ReadAsPropertyName(
            ref Utf8JsonReader reader,
            Type typeToConvert,
            JsonSerializerOptions options) =>
                Read(ref reader, typeToConvert, options);
    }

    // TypeConverter for {{relatedClass.Name}} to and from string and {{relatedClass.InnerTypeName}}
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || sourceType == typeof({{relatedClass.InnerTypeName}}) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || destinationType == typeof({{relatedClass.InnerTypeName}}) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return TryParse(s) ?? default;
            }

            if (value is {{relatedClass.InnerTypeName}} g)
            {
                return new {{relatedClass.Name}}(g);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type)
            {
                if (destinationType == typeof(string))
                {
                    return type.ToString();
                }

                if (destinationType == typeof({{relatedClass.InnerTypeName}}))
                {
                    return type.Value;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly string InnerTypeName;
        public readonly bool IsPublic;

        public GeneratorParams(string name, string ns, string innerTypeName, bool isPublic)
        {
            this.Name = name;
            this.Namespace = ns;
            this.IsPublic = isPublic;
            this.FullyQualifiedName = string.Join(".", ns, name);
            this.InnerTypeName = innerTypeName;
        }
    }
}
