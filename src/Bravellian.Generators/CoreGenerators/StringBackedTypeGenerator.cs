// Copyright (c) Samuel McAravey
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace Bravellian.Generators;


public static class StringBackedTypeGenerator
{
    public static GeneratorParams? GetParams(XElement xml, IBvLogger? logger)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        var additionalProperties = xml.Elements("Property").Select(e => e.GetAttributeDict()).Select(a => (a["type"].ToString(), a["name"].ToString())).ToList();
        return new(attributes.TryGetValue("name")!, attributes.TryGetValue("namespace")!, true, attributes.TryGetValue("regex"), attributes.TryGetValue("regex-const"), additionalProperties);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBvLogger? logger)
    {
        try
        {
            if (structToGenerate is { } sg)
            {
                string result = (sg.RegexConstName, sg.RegexMatch) switch
                {
                    (null, null) => GenerateClass(in sg),
                    (null, not null) => GenerateClassWithRegex(in sg),
                    (not null, _) => GenerateClassWithRegexConst(in sg),
                };

                return result;
            }
        }
        catch (System.Exception ex)
        {
            logger?.LogErrorFromException(ex);
        }

        return null;
    }

    private static string GenerateClass(in GeneratorParams relatedClass)
    {
        string additionalProperties = string.Empty;
        string processValueSignature = "static partial void ProcessValue(string value);";
        string constructorInit = "        ProcessValue(value);";
        if (relatedClass.AdditionalProperties is { Count: > 0 })
        {
            additionalProperties = "\r\n\r\n" + string.Join("\r\n\r\n", relatedClass.AdditionalProperties.Select(p => $"    public {p.Type} {p.Name} {{ get; init; }}"));
            var outParams = string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"));
            processValueSignature = $"private static partial void ProcessValue(string value, {outParams});";
            constructorInit = $$"""
                    ProcessValue(value, {{string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"))}});
            {{string.Join("\r\n", relatedClass.AdditionalProperties.Select(p => $"        this.{p.Name} = {p.Name.ToLower()};"))}}
            """;
        }

        return $$"""
// <auto-generated/>
// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>,
          Bravellian.IHasValueConverter,
          Bravellian.IPwParsable<{{relatedClass.Name}}>,
          Bravellian.IStringBackedType<{{relatedClass.Name}}>
{
    private {{relatedClass.Name}}(string value)
    {
        this.Value = value;
{{constructorInit}}
    }

    public string Value { get; init; }{{additionalProperties}}

    {{processValueSignature}}

    public override string ToString() => this.Value;

    public bool Equals({{relatedClass.Name}} other)
    {
        return string.Equals(this.Value, other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value?.GetHashCode() ?? 0;
    }

    public int CompareTo({{relatedClass.Name}} other)
    {
        return string.Compare(this.Value, other.Value);
    }

    public int CompareTo(object? obj)
    {
        return obj is {{relatedClass.Name}} id ? this.Value.CompareTo(id.Value) : this.Value.CompareTo(obj);
    }

    public static bool TryParse([NotNullWhen(true)] string value, [MaybeNullWhen(false)] [NotNullWhen(true)] out {{relatedClass.Name}} result)
    {
        if (value == null)
        {
            result = default;
            return false;
        }

        try
        {
            result = new {{relatedClass.Name}}(value);
            return true;
        }
        catch
        {
            result = default;
            return false;
        }
    }

    public static bool TryParse([NotNullWhen(true)] string? value, IFormatProvider? provider, [MaybeNullWhen(false)] [NotNullWhen(true)] out {{relatedClass.Name}} result)
    {
        if (value == null)
        {
            result = default;
            return false;
        }

        try
        {
            result = new {{relatedClass.Name}}(value);
            return true;
        }
        catch
        {
            result = default;
            return false;
        }
    }

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (value == null)
        {
            return null;
        }

        if ({{relatedClass.Name}}.TryParse(value, out {{relatedClass.Name}} result))
        {
            return result;
        }

        return null;
    }

    public static {{relatedClass.Name}} Parse(string value)
    {
        if (value == null)
        {
            throw new ArgumentNullException(nameof(value));
        }

        return new {{relatedClass.Name}}(value);
    }

    public static {{relatedClass.Name}} Parse(string value, IFormatProvider? provider)
    {
        if (value == null)
        {
            throw new ArgumentNullException(nameof(value));
        }

        return new {{relatedClass.Name}}(value);
    }

    public static {{relatedClass.Name}} GenerateRandom()
    {
        return new {{relatedClass.Name}}(Guid.NewGuid().ToString("N"));
    }

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.Name}}.TryParse(s, out {{relatedClass.Name}} result))
            {
                return result;
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value);

        public override void WriteAsPropertyName(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WritePropertyName(value.Value);

        public override {{relatedClass.Name}} ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            return this.Read(ref reader, typeToConvert, options);
        }
    }

    // TypeConverter for {{relatedClass.Name}} to and from string
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return {{relatedClass.Name}}.TryParse(s) ?? default;
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type && destinationType == typeof(string))
            {
                return type.ToString();
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    private static string GenerateClassWithRegex(in GeneratorParams relatedClass)
    {
        string additionalProperties = string.Empty;
        string processValueSignature = "static partial void ProcessValue(string value);";
        string constructorInit = "        ProcessValue(value);";
        if (relatedClass.AdditionalProperties is { Count: > 0 })
        {
            additionalProperties = "\r\n\r\n" + string.Join("\r\n\r\n", relatedClass.AdditionalProperties.Select(p => $"    public {p.Type} {p.Name} {{ get; init; }}"));
            var outParams = string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"));
            processValueSignature = $"private static partial void ProcessValue(string value, {outParams});";
            constructorInit = $$"""
                    ProcessValue(value, {{string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"))}});
            {{string.Join("\r\n", relatedClass.AdditionalProperties.Select(p => $"        this.{p.Name} = {p.Name.ToLower()};"))}}
            """;
        }

        return $$"""
// <auto-generated/>
// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          Bravellian.IHasValueConverter,
          Bravellian.IPwParsable<{{relatedClass.Name}}>,
          Bravellian.IStringBackedType<{{relatedClass.Name}}>
{
    public const string RegexString = @"{{relatedClass.RegexMatch}}";
    public const string ExactRegexString = $"^{RegexString}$";
    public static Regex ValidationRegex = new Regex(ExactRegexString, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(1000));

    public {{relatedClass.Name}}(string value)
    {
        ValidateValueOrThrow(value);
        this.Value = value;
{{constructorInit}}
    }

    public string Value { get; init; }{{additionalProperties}}

    {{processValueSignature}}

    public override string ToString() => this.Value;

    private static void ValidateValueOrThrow(string value)
    {
        if (!ValidationRegex.IsMatch(value))
        {
            throw new ArgumentOutOfRangeException($"The value {value} does not match the expected regular expression: " + @"'{{relatedClass.RegexMatch}}'");
        }
    }

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.Value.CompareTo(other.Value);
    }

    public int CompareTo(object? obj)
    {
        return obj is {{relatedClass.Name}} id ? this.Value.CompareTo(id.Value) : this.Value.CompareTo(obj);
    }

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (ValidationRegex.IsMatch(value))
        {
            return new {{relatedClass.Name}}(value);
        }

        return null;
    }

    public static bool TryParse([NotNullWhen(true)] string? value, [MaybeNullWhen(false)] [NotNullWhen(true)] out {{relatedClass.Name}} result)
    {
        if (value == null)
        {
            result = default;
            return false;
        }

        if (ValidationRegex.IsMatch(value))
        {
            try
            {
                result = new {{relatedClass.Name}}(value);
                return true;
            }
            catch
            {
                result = default;
                return false;
            }
        }

        result = default;
        return false;
    }

    public static {{relatedClass.Name}} Parse(string value)
    {
        if (ValidationRegex.IsMatch(value))
        {
            return new {{relatedClass.Name}}(value);
        }

        throw new ArgumentOutOfRangeException($"The value {value} does not match the expected regular expression: " + @"'{{relatedClass.RegexMatch}}'");
    }

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.Name}}.TryParse(s, out {{relatedClass.Name}} result))
            {
                return result;
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value);

        public override void WriteAsPropertyName(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WritePropertyName(value.Value);

        public override {{relatedClass.Name}} ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            return this.Read(ref reader, typeToConvert, options);
        }
    }

    // TypeConverter for {{relatedClass.Name}} to and from string
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return new {{relatedClass.Name}}(s);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type && destinationType == typeof(string))
            {
                return type.ToString();
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    private static string GenerateClassWithRegexConst(in GeneratorParams relatedClass)
    {
        string additionalProperties = string.Empty;
        string processValueSignature = "static partial void ProcessValue(string value);";
        string constructorInit = "        ProcessValue(value);";
        if (relatedClass.AdditionalProperties is { Count: > 0 })
        {
            additionalProperties = "\r\n\r\n" + string.Join("\r\n\r\n", relatedClass.AdditionalProperties.Select(p => $"    public {p.Type} {p.Name} {{ get; init; }}"));
            var outParams = string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"));
            processValueSignature = $"private static partial void ProcessValue(string value, {outParams});";
            constructorInit = $$"""
                    ProcessValue(value, {{string.Join(", ", relatedClass.AdditionalProperties.Select(p => $"out {p.Type} {p.Name.ToLower()}"))}});
            {{string.Join("\r\n", relatedClass.AdditionalProperties.Select(p => $"        this.{p.Name} = {p.Name.ToLower()};"))}}
            """;
        }

        return $$"""
// <auto-generated/>
// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          Bravellian.IHasValueConverter,
          Bravellian.IStringBackedType<{{relatedClass.Name}}>
{
    public const string ExactRegexString = $"^{{{relatedClass.RegexConstName}}}$";
    public static Regex ValidationRegex = new Regex(ExactRegexString, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(1000));

    public {{relatedClass.Name}}(string value)
    {
        ValidateValueOrThrow(value);
        this.Value = value;
{{constructorInit}}
    }

    public string Value { get; init; }{{additionalProperties}}

    {{processValueSignature}}

    public override string ToString() => this.Value;

    private static void ValidateValueOrThrow(string value)
    {
        if (!ValidationRegex.IsMatch(value))
        {
            throw new ArgumentOutOfRangeException($"The value {value} does not match the expected regular expression: " + {{relatedClass.RegexConstName}});
        }
    }

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.Value.CompareTo(other.Value);
    }

    public int CompareTo(object? obj)
    {
        return obj is {{relatedClass.Name}} id ? this.Value.CompareTo(id.Value) : this.Value.CompareTo(obj);
    }

    public static {{relatedClass.Name}}? TryParse(string? value)
    {
        if (ValidationRegex.IsMatch(value))
        {
            return new {{relatedClass.Name}}(value);
        }

        return null;
    }

    public static bool TryParse([NotNullWhen(true)] string? value, [MaybeNullWhen(false)] [NotNullWhen(true)] out {{relatedClass.Name}} result)
    {
        if (value == null)
        {
            result = default;
            return false;
        }

        if (ValidationRegex.IsMatch(value))
        {
            try
            {
                result = new {{relatedClass.Name}}(value);
                return true;
            }
            catch
            {
                result = default;
                return false;
            }
        }

        result = default;
        return false;
    }

    public static {{relatedClass.Name}} Parse(string value)
    {
        if (ValidationRegex.IsMatch(value))
        {
            return new {{relatedClass.Name}}(value);
        }

        throw new ArgumentOutOfRangeException($"The value {value} does not match the expected regular expression: {{{relatedClass.RegexConstName}}}");
    }

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && {{relatedClass.Name}}.TryParse(s, out {{relatedClass.Name}} result))
            {
                return result;
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value);

        public override void WriteAsPropertyName(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WritePropertyName(value.Value);

        public override {{relatedClass.Name}} ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            return this.Read(ref reader, typeToConvert, options);
        }
    }

    // TypeConverter for {{relatedClass.Name}} to and from string
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return new {{relatedClass.Name}}(s);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type && destinationType == typeof(string))
            {
                return type.ToString();
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly bool IsPublic;
        public readonly string? RegexMatch;
        public readonly string? RegexConstName;
        public readonly IReadOnlyList<(string Type, string Name)>? AdditionalProperties;

        public GeneratorParams(string name, string ns, bool isPublic, string? regex, string? regexConstName, IReadOnlyList<(string Type, string Name)>? additionalProperties)
        {
            this.Name = name;
            this.Namespace = ns;
            this.IsPublic = isPublic;
            this.FullyQualifiedName = string.Join(".", ns, name);
            this.RegexMatch = regex;
            this.RegexConstName = regexConstName;
            this.AdditionalProperties = additionalProperties;
        }
    }
}
