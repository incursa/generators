// Copyright (c) Bravellian
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#nullable enable

namespace Bravellian.Generators;

using System.Collections.Generic;
using System.Xml.Linq;

public static class GuidBackedTypeGenerator
{
    public static GeneratorParams? GetParams(XElement xml, IBvLogger? logger)
    {
        IReadOnlyDictionary<string, string> attributes = xml.GetAttributeDict();
        var useDefaultFormat = attributes.TryGetValue("default-format", out var defaultFormatString) && bool.TryParse(defaultFormatString, out var defaultFormat) && defaultFormat;
        return new (attributes!.TryGetValue("name"), attributes!.TryGetValue("namespace"), true, useDefaultFormat);
    }

    public static string? Generate(GeneratorParams? structToGenerate, IBvLogger? logger)
    {
        if (structToGenerate.HasValue)
        {
            return GenerateClass(structToGenerate.Value);
        }
        else
        {
            return null;
        }
    }

    private static string GenerateClass(GeneratorParams relatedClass)
    {
        return $$"""
// <auto-generated/>
// CONFIDENTIAL - Copyright (c) Bravellian LLC. All rights reserved.
// See NOTICE.md for full restrictions and usage terms.

#nullable enable

namespace {{relatedClass.Namespace}};

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

[JsonConverter(typeof({{relatedClass.Name}}JsonConverter))]
[TypeConverter(typeof({{relatedClass.Name}}TypeConverter))]
public readonly partial record struct {{relatedClass.Name}}
        : IComparable,
          IComparable<{{relatedClass.Name}}>,
          IEquatable<{{relatedClass.Name}}>,
          ISpanParsable<{{relatedClass.Name}}>,
          IParsable<{{relatedClass.Name}}>,
          Bravellian.IHasValueConverter,
          Bravellian.IPwParsable<{{relatedClass.Name}}>,
          Bravellian.IGuidBackedType<{{relatedClass.Name}}>
{
    public const string ExactValidationRegexString = $"^{FullValidationRegexString}$";
    public const string FullValidationRegexString = "(?#GUID match)(?![({]?[0]{8}[-]?(?>[0]{4}[-]?){3}[0]{12}[})]?)[({]?[a-fA-F0-9]{8}[-]?(?>[a-fA-F0-9]{4}[-]?){3}[a-fA-F0-9]{12}[})]?";

    public static readonly {{relatedClass.Name}} Empty = new(Guid.Empty);

    public {{relatedClass.Name}}(Guid value)
    {
        this.Value = value;
    }

    public Guid Value { get; init; }

    public static {{relatedClass.Name}} GenerateNew() => new(Guid.NewGuid());

    public static {{relatedClass.Name}} Parse(ReadOnlySpan<char> s, IFormatProvider provider)
    {
        var id = Guid.Parse(s, provider);
        return new {{relatedClass.Name}}(id);
    }

    public static {{relatedClass.Name}} Parse([StringSyntax(StringSyntaxAttribute.GuidFormat)] string s, IFormatProvider provider)
    {
        var id = Guid.Parse(s, provider);
        return new {{relatedClass.Name}}(id);
    }

    public static {{relatedClass.Name}} Parse([StringSyntax(StringSyntaxAttribute.GuidFormat)] string value) => new(Guid.Parse(value));

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider provider, out {{relatedClass.Name}} result)
    {
        if (Guid.TryParse(s, provider, out Guid id))
        {
            result = new {{relatedClass.Name}}(id);
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryParse([StringSyntax(StringSyntaxAttribute.GuidFormat)] [NotNullWhen(true)] string s, IFormatProvider provider, out {{relatedClass.Name}} result)
    {
        if (Guid.TryParse(s, provider, out Guid id))
        {
            result = new {{relatedClass.Name}}(id);
            return true;
        }

        result = default;
        return false;
    }

    public static {{relatedClass.Name}}? TryParse([StringSyntax(StringSyntaxAttribute.GuidFormat)] string value)
    {
        if (Guid.TryParse(value, out Guid result))
        {
            return new {{relatedClass.Name}}(result);
        }

        return null;
    }

    public static bool TryParse([StringSyntax(StringSyntaxAttribute.GuidFormat)] string value, out {{relatedClass.Name}} id)
    {
        if (Guid.TryParse(value, out Guid result))
        {
            id = new {{relatedClass.Name}}(result);
            return true;
        }

        id = default;
        return false;
    }

    public int CompareTo({{relatedClass.Name}} other)
    {
        return this.Value.CompareTo(other.Value);
    }

    public int CompareTo(object? obj)
    {
        if (obj is {{relatedClass.Name}} id)
        {
            return this.Value.CompareTo(id.Value);
        }

        return this.Value.CompareTo(obj);
    }

    public bool Equals({{relatedClass.Name}} other)
    {
        return this.Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }

    public override string ToString() => this.Value.ToString({{(relatedClass.UseDefaultFormat ? string.Empty : "\"N\"")}});

    public string ToString(string format) => this.Value.ToString(format);

    public class {{relatedClass.Name}}JsonConverter : JsonConverter<{{relatedClass.Name}}>
    {
        public override {{relatedClass.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();

            if (!string.IsNullOrEmpty(s) && Guid.TryParse(s, out Guid id))
            {
                return new {{relatedClass.Name}}(id);
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, {{relatedClass.Name}} value, JsonSerializerOptions options) =>
            writer.WriteStringValue(value.Value.ToString());

        public override void WriteAsPropertyName(
            Utf8JsonWriter writer,
            {{relatedClass.Name}} value,
            JsonSerializerOptions options) =>
                writer.WritePropertyName(value.ToString());

        public override {{relatedClass.Name}} ReadAsPropertyName(
            ref Utf8JsonReader reader,
            Type typeToConvert,
            JsonSerializerOptions options) =>
                Read(ref reader, typeToConvert, options);
    }

    // TypeConverter for {{relatedClass.Name}} to and from string and Guid
    public class {{relatedClass.Name}}TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) =>
            sourceType == typeof(string) || sourceType == typeof(Guid) || base.CanConvertFrom(context, sourceType);

        public override bool CanConvertTo(ITypeDescriptorContext? context, [NotNullWhen(true)] Type? destinationType) =>
            destinationType == typeof(string) || destinationType == typeof(Guid) || base.CanConvertTo(context, destinationType);

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            if (value is string s)
            {
                return TryParse(s) ?? default;
            }

            if (value is Guid g)
            {
                return new {{relatedClass.Name}}(g);
            }

            return base.ConvertFrom(context, culture, value) ?? default;
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is {{relatedClass.Name}} type)
            {
                if (destinationType == typeof(string))
                {
                    return type.ToString();
                }

                if (destinationType == typeof(Guid))
                {
                    return type.Value;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}

""";
    }

    public readonly record struct GeneratorParams
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly bool IsPublic;
        public readonly bool UseDefaultFormat;

        public GeneratorParams(string name, string ns, bool isPublic, bool useDefaultFormat)
        {
            this.Name = name;
            this.Namespace = ns;
            this.IsPublic = isPublic;
            this.FullyQualifiedName = string.Join(".", ns, name);
            this.UseDefaultFormat = useDefaultFormat;
        }
    }
}
